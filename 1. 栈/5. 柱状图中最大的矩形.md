## 原题地址
[柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

难度：困难
## 题解
### 题解1 暴力解法 双重循环(超出时间限制)
#### 1. 问题分析
枚举宽，两层遍历，求得所有组合区间内的矩形面积
#### 2. 解题思路
1. 两层循环
2. 获取该区间内最小高度
3. 比较当前面积与上一个面积，保留最大的
```js
var largestRectangleArea = function(heights) {
    const len = heights.length;
    let ans = 0;
    for (let left = 0; left < len; left++) {
        let minHeight = Infinity
        for (let right = left; right < len; right++) {
            minHeight = Math.min(minHeight, heights[right])
            ans = Math.max(ans, minHeight * (right - left + 1))
        }
    }
    return ans;
};
```
#### 3. 复杂度分析
时间复杂度O(n^2)，空间复杂度：O(n)
### 题解2 暴力法(超出时间限制)
#### 1. 问题分析
使用一重循环遍历每一根柱子，从柱子开始向两侧延伸，遇到小于该柱子的高度时，就是边界。

#### 2. 解题思路
1. 遍历每根柱子
2. 往左(右)遍历，直到遇到比该柱子小的柱子
3. 比较面积，获取每次的最大值
```js
var largestRectangleArea = function(heights) {
    const len = heights.length;
    // 特判
    if (len == 0) {
        return 0;
    }

    let res = 0;
    for (let i = 0; i < len; i++) {

        // 找左边最后 1 个大于等于 heights[i] 的下标
        let left = i;
        let curHeight = heights[i];
        while (left > 0 && heights[left - 1] >= curHeight) {
            left--;
        }

        // 找右边最后 1 个大于等于 heights[i] 的索引
        let right = i;
        while (right < len - 1 && heights[right + 1] >= curHeight) {
            right++;
        }

        let width = right - left + 1;
        res = Math.max(res, width * curHeight);
    }
    return res;
}
```
#### 3. 复杂度分析
时间复杂度O(n^2)，空间复杂度：O(n)

###  题解3
```js
var largestRectangleArea = function(heights) {
    const len = heights.length;
    if (len === 0) {
        return 0;
    }
    if (len === 1) {
        return heights[0];
    }

    let res = 0;
    const stack = [];
    for (let i = 0; i < len; i++) {
        while (stack.length && heights[stack[stack.length - 1]] > heights[i]) {
            const h = heights[stack[stack.length - 1]];
            stack.pop();
            let w = i;
            if (stack.length) {
                w = i - stack[stack.length - 1] - 1;
            }
            res = Math.max(res, h * w);
        }
        stack.push(i);
    }
    while (stack.length) {
        const h = heights[stack[stack.length - 1]];
        stack.pop();
        let w = len;
        if (stack.length) {
            w = len - stack[stack.length - 1] - 1;
        }
        res = Math.max(res, h * w);
    }
    return res;
}
```

## 高赞题解
[官方题解](https://leetcode-cn.com/problems/valid-parentheses/solution/you-xiao-de-gua-hao-by-leetcode-solution/)  
[辅助栈法，极简+图解](https://leetcode-cn.com/problems/valid-parentheses/solution/valid-parentheses-fu-zhu-zhan-fa-by-jin407891080/)  
[逐步分析，图解栈](https://leetcode-cn.com/problems/valid-parentheses/solution/zhu-bu-fen-xi-tu-jie-zhan-zhan-shi-zui-biao-zhun-d/)  
